## 个人理解

 1. 协程基于swoole进程
 2. Swoole启动时会创建2 + n + m个进程，其中n为Worker进程数，m为TaskWorker进程数，2为一个Master进程和一个Manager进程，它们之间的关系如下图所示。
 ![](https://i.imgur.com/wPT0SLG.png)
   其中，Master进程为主进程，该进程会创建Manager进程、Reactor线程等工作进/线程。

  * Reactor线程实际运行epoll实例，用于accept客户端连接以及接收客户端数据；
  * Manager进程为管理进程，该进程的作用是创建、管理所有的Worker进程和TaskWorker进程。
	
	##### Worker进程简介
	Worker进程作为Swoole的工作进程，所有的业务逻辑代码均在此进程上运行。当Reactor线程接收到来自客户端的数据后，会将数据打包通过管道发送给某个Worker进程

	##### Worker进程生命周期
	一个Worker进程的生命周期如图所示：
	当一个Worker进程被成功创建后，会调用onWorkerStart回调，随后进入事件循环等待数据。当通过回调函数接收到数据后，开始处理数据。如果处理数据过程中出现严重错误导致进程退出，或者Worker进程处理的总请求数达到指定上限，则Worker进程调用onWorkerStop回调并结束进程。

 3. 以Hyperf为例子，当启动Hyperf，框架会创建上面所讲的几个进程,当有请求进来时，Worker进程会对请求进行处理，当遇到I/O操作时（如连接数据库，等待数据库响应等），Worker的协程调度器会将当前业务交给TaskWorker进程，Worker继续处理新的逻辑，无需等待耗时任务的执行。
 4. 启动Hyperf后，2所讲的进程会一直启动，等待请求进来，这里跟PHP-FPM的进程池很像。

## Hyperf官方文档解释：

###协程是什么？

我们已经知道了协程可以很好的解决异步非阻塞系统的开发问题，那么协程本身到底是什么呢？从定义上来说，协程是一种轻量级的线程，由用户代码来调度和管理，而不是由操作系统内核来进行调度，也就是在用户态进行。可以直接的理解为就是一个非标准的线程实现，但什么时候切换由用户自己来实现，而不是由操作系统分配 CPU 时间决定。具体来说，Swoole 的每个 Worker进程 会存在一个协程调度器来调度协程，协程切换的时机就是遇到 I/O 操作或代码显性切换时，进程内以单线程的形式运行协程，也就意味着一个进程内同一时间只会有一个协程在运行且切换时机明确，也就无需处理像多线程编程下的各种同步锁的问题。
单个协程内的代码运行仍是串行的，放在一个 HTTP 协程服务上来理解就是每一个请求是一个协程，举个例子，假设为请求A创建了 协程A，为 请求B 创建了 协程B，那么在处理 协程A 的时候代码跑到了查询 MySQL 的语句上，这个时候 协程A 则会触发协程切换，协程A 就继续等待 I/O 设备返回结果，那么此时就会切换到 协程B，开始处理 协程B 的逻辑，当又遇到了一个 I/O 操作便又触发协程切换，再回过来从 协程A 刚才切走的地方继续执行，如此反复，遇到 I/O 操作就切换到另一个协程去继续执行而非一直阻塞等待。
这里可以发现一个问题就是，协程A 的 MySQL 查询操作必须得是一个异步非阻塞的操作，否则会由于阻塞导致协程调度器没法切换到另一个协程继续执行，这个也是要在协程编程下需要规避的问题之一

## [廖雪峰python教程](https://www.liaoxuefeng.com/wiki/897692888725344/923057403198272)解释

协程，又称微线程，纤程。英文名Coroutine。

协程的概念很早就提出来了，但直到最近几年才在某些语言（如Lua）中得到广泛应用。

子程序，或者称为函数，在所有语言中都是层级调用，比如A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完毕返回，最后是A执行完毕。

所以子程序调用是通过栈实现的，一个线程就是执行一个子程序。

子程序调用总是一个入口，一次返回，调用顺序是明确的。而协程的调用和子程序不同。

协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。

注意，在一个子程序中中断，去执行其他子程序，不是函数调用，有点类似CPU的中断。比如子程序A、B：

	def A():
	    print '1'
	    print '2'
	    print '3'
	
	def B():
	    print 'x'
	    print 'y'
	    print 'z'
假设由协程执行，在执行A的过程中，可以随时中断，去执行B，B也可能在执行过程中中断再去执行A，结果可能是：

	1
	2
	x
	y
	3
	z

